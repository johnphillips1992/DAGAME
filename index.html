<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grid Mechanics - Strategic Puzzle</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #0a0a0a;
            color: white;
            font-family: monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        canvas {
            border: 2px solid #333;
            background: #000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            width: 512px;
            height: 512px;
        }
        
        #info {
            margin-top: 15px;
            text-align: center;
            font-size: 13px;
        }
        
        h1 {
            margin: 10px 0;
            color: #ffd700;
            font-size: 20px;
            letter-spacing: 3px;
        }
        
        .stats {
            margin: 8px 0;
            padding: 6px 15px;
            background: #1a1a1a;
            border: 1px solid #333;
            display: inline-block;
        }
        
        .legend {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 10px auto;
            max-width: 600px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 11px;
        }
        
        .color-box {
            width: 12px;
            height: 12px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <h1>GRID MECHANICS</h1>
    <canvas id="gameCanvas"></canvas>
    <div id="info">
        <div class="stats">
            <strong>Moves: <span id="moves">0</span> | Best: <span id="best">--</span></strong>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 64;
        canvas.width = GRID_SIZE;
        canvas.height = GRID_SIZE;

        // Game state
        let moves = 0;
        let gameWon = false;
        let gameOver = false;
        let bestScore = null;
        
        // Colors
        const COLORS = {
            EMPTY: '#000000',
            PLAYER: '#ffd700',
            WALL: '#333333',
            PUSHBLOCK: '#ff6b6b',
            GOAL: '#4dabf7',
            PUSHBLOCK_ON_GOAL: '#ff00ff',
            SPRING: '#00ff00',
            TELEPORTER_IN: '#ff00ff',
            TELEPORTER_OUT: '#ff88ff',
            ICE: '#00ffff',
            GRID: '#0a0a0a'
        };

        // Level data - Ice mechanics with teleporters
        const LEVEL = {
            player: {x: 50, y: 25},
            walls: createLevelWalls([
                '################################################################',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#######################..................#######################',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#..............................................................#',
                '#..............................................................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '################################################################',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#######################..................#######################',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#........................................#',
                '#.....................#........................................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#..................#.....................#',
                '#.....................#####################################....#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '#..............................................................#',
                '################################################################'
            ]),
            pushBlocks: [{x: 30, y: 50}, {x: 34, y: 50}, {x: 10, y: 35}, {x: 54, y: 35}],
            goals: [{x: 10, y: 15}, {x: 54, y: 5}, {x: 10, y: 45}, {x: 54, y: 55}],
            springs: [{x: 32, y: 40}],
            teleportersIn: [{x: 5, y: 30}, {x: 26, y: 46}, {x: 32, y: 30}, {x: 35, y: 12 },{x: 58, y: 30}],
            teleportersOut: [{x: 5, y: 12}, {x: 26, y: 56}, {x: 32, y: 12}, {x: 35, y: 30 }, {x: 58, y: 12}],
            ice: []
        };

        function createLevelWalls(asciiMap) {
            const walls = [];
            for (let y = 0; y < asciiMap.length && y < 64; y++) {
                for (let x = 0; x < asciiMap[y].length && x < 64; x++) {
                    if (asciiMap[y][x] === '#') {
                        walls.push({x, y});
                    }
                }
            }
            return walls;
        }

        let player, walls, pushBlocks, goals, springs, teleportersIn, teleportersOut, ice;

        function loadLevel() {
            player = {...LEVEL.player};
            walls = [...LEVEL.walls];
            pushBlocks = LEVEL.pushBlocks.map(b => ({...b}));
            goals = [...LEVEL.goals];
            springs = [...LEVEL.springs];
            teleportersIn = [...LEVEL.teleportersIn];
            teleportersOut = [...LEVEL.teleportersOut];
            ice = [...LEVEL.ice];
            
            moves = 0;
            gameWon = false;
            gameOver = false;
            updateDisplay();
            draw();
        }

        function draw() {
            ctx.fillStyle = COLORS.EMPTY;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw ice tiles
            ctx.fillStyle = COLORS.ICE;
            ice.forEach(tile => {
                ctx.fillRect(tile.x, tile.y, 1, 1);
            });
            
            // Draw teleporter inputs
            ctx.fillStyle = COLORS.TELEPORTER_IN;
            teleportersIn.forEach(tp => {
                ctx.fillRect(tp.x, tp.y, 1, 1);
            });
            
            // Draw teleporter outputs
            ctx.fillStyle = COLORS.TELEPORTER_OUT;
            teleportersOut.forEach(tp => {
                ctx.fillRect(tp.x, tp.y, 1, 1);
            });
            
            // Draw springs
            ctx.fillStyle = COLORS.SPRING;
            springs.forEach(spring => {
                ctx.fillRect(spring.x, spring.y, 1, 1);
            });
            
            // Draw goals
            ctx.fillStyle = COLORS.GOAL;
            goals.forEach(goal => {
                ctx.fillRect(goal.x, goal.y, 1, 1);
            });
            
            // Draw walls
            ctx.fillStyle = COLORS.WALL;
            walls.forEach(wall => {
                ctx.fillRect(wall.x, wall.y, 1, 1);
            });
            
            // Draw push blocks
            pushBlocks.forEach(block => {
                const isOnGoal = goals.some(g => g.x === block.x && g.y === block.y);
                ctx.fillStyle = isOnGoal ? COLORS.PUSHBLOCK_ON_GOAL : COLORS.PUSHBLOCK;
                ctx.fillRect(block.x, block.y, 1, 1);
            });
            
            // Draw player
            ctx.fillStyle = COLORS.PLAYER;
            ctx.fillRect(player.x, player.y, 1, 1);
            
            // Win overlay
            if (gameWon) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ffd700';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('COMPLETE!', 32, 30);
                ctx.font = '4px monospace';
                ctx.fillText(`Moves: ${moves}`, 32, 36);
                if (bestScore) {
                    ctx.fillText(`Best: ${bestScore}`, 32, 42);
                }
                ctx.fillText('Press R to play again', 32, 48);
            }

            if (gameOver) {
                ctx.fillStyle = 'rgba(0, 0, 0, 0.85)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.fillStyle = '#ff0000';
                ctx.font = '8px monospace';
                ctx.textAlign = 'center';
                ctx.fillText('GAME OVER', 32, 30);
                ctx.font = '4px monospace';
                ctx.fillText('Too many moves!', 32, 36);
                ctx.fillText('Press R to restart', 32, 42);
            }
        }

        function isBlocked(x, y, excludeBlock = null) {
            if (x < 0 || x >= 64 || y < 0 || y >= 64) return true;
            if (walls.some(w => w.x === x && w.y === y)) return true;
            if (pushBlocks.some(b => b !== excludeBlock && b.x === x && b.y === y)) return true;
            return false;
        }

        function processSpecialTiles(entity, isPlayer = false) {
            let processed = true;
            let iterations = 0;
            
            while (processed && iterations < 100) { // Prevent infinite loops
                processed = false;
                iterations++;
                
                // Check for spring
                if (springs.some(s => s.x === entity.x && s.y === entity.y)) {
                    // Launch upward
                    let launchY = entity.y - 1;
                    if (isPlayer) {
                        while (launchY >= 0 && !walls.some(w => w.x === entity.x && w.y === launchY) &&
                               !pushBlocks.some(b => b.x === entity.x && b.y === launchY)) {
                            launchY--;
                        }
                    } else {
                        while (launchY >= 0 && !isBlocked(entity.x, launchY, entity)) {
                            launchY--;
                        }
                    }
                    if (launchY < entity.y - 1) {
                        entity.y = launchY + 1;
                        processed = true;
                    }
                }
                
                // Check for teleporter input
                const tpIndex = teleportersIn.findIndex(t => t.x === entity.x && t.y === entity.y);
                if (tpIndex !== -1 && tpIndex < teleportersOut.length) {
                    const output = teleportersOut[tpIndex];
                    if (isPlayer) {
                        if (!walls.some(w => w.x === output.x && w.y === output.y) &&
                            !pushBlocks.some(b => b.x === output.x && b.y === output.y)) {
                            entity.x = output.x;
                            entity.y = output.y;
                            processed = true;
                        }
                    } else {
                        if (!isBlocked(output.x, output.y, entity)) {
                            entity.x = output.x;
                            entity.y = output.y;
                            processed = true;
                        }
                    }
                }
            }
        }

        function moveBlock(block, dx, dy) {
            let newX = block.x + dx;
            let newY = block.y + dy;
            
            // Check if movement is blocked
            if (isBlocked(newX, newY, block)) {
                return false;
            }
            
            // Check if on ice - continue sliding
            if (ice.some(i => i.x === block.x && i.y === block.y)) {
                while (!isBlocked(newX, newY, block) && ice.some(i => i.x === newX && i.y === newY)) {
                    block.x = newX;
                    block.y = newY;
                    newX += dx;
                    newY += dy;
                }
                if (!isBlocked(newX, newY, block)) {
                    block.x = newX;
                    block.y = newY;
                }
            } else {
                block.x = newX;
                block.y = newY;
            }
            
            // Process special tiles (springs and teleporters)
            processSpecialTiles(block, false);
            
            return true;
        }

        function movePlayer(dx, dy) {
            if (gameWon || gameOver) return;
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            if (newX < 0 || newX >= 64 || newY < 0 || newY >= 64) return;
            if (walls.some(w => w.x === newX && w.y === newY)) return;
            
            const block = pushBlocks.find(b => b.x === newX && b.y === newY);
            if (block) {
                if (!moveBlock(block, dx, dy)) return;
            }
            
            // Check if player is on ice for sliding
            if (ice.some(i => i.x === player.x && i.y === player.y)) {
                let slideX = newX;
                let slideY = newY;
                while (!walls.some(w => w.x === slideX && w.y === slideY) &&
                       !pushBlocks.some(b => b.x === slideX && b.y === slideY) &&
                       slideX >= 0 && slideX < 64 && slideY >= 0 && slideY < 64 &&
                       ice.some(i => i.x === slideX && i.y === slideY)) {
                    player.x = slideX;
                    player.y = slideY;
                    slideX += dx;
                    slideY += dy;
                }
                if (!walls.some(w => w.x === slideX && w.y === slideY) &&
                    !pushBlocks.some(b => b.x === slideX && b.y === slideY) &&
                    slideX >= 0 && slideX < 64 && slideY >= 0 && slideY < 64) {
                    player.x = slideX;
                    player.y = slideY;
                }
            } else {
                player.x = newX;
                player.y = newY;
            }
            
            moves++;
            if (moves >= 500) {
                gameOver = true;
            }
            // Process special tiles for player (springs and teleporters)
            processSpecialTiles(player, true);
            
            updateDisplay();
            
            if (pushBlocks.every(b => goals.some(g => g.x === b.x && g.y === b.y))) {
                gameWon = true;
                if (!bestScore || moves < bestScore) {
                    bestScore = moves;
                }
            }
            
            draw();
        }

        function updateDisplay() {
            document.getElementById('moves').textContent = moves;
            document.getElementById('best').textContent = bestScore || '--';
        }

        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': e.preventDefault(); movePlayer(0, -1); break;
                case 'ArrowDown': e.preventDefault(); movePlayer(0, 1); break;
                case 'ArrowLeft': e.preventDefault(); movePlayer(-1, 0); break;
                case 'ArrowRight': e.preventDefault(); movePlayer(1, 0); break;
                case 'r': case 'R': loadLevel(); break;
            }
        });

        loadLevel();
    </script>
</body>
</html>